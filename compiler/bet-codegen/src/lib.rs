// SPDX-License-Identifier: MIT OR Apache-2.0
//! Code generation for Betlang
//!
//! Targets:
//! - JavaScript (for web)
//! - LLVM IR (for native)
//! - BEAM bytecode (for Erlang VM)

use bet_syntax::ast::*;
use bet_core::CompileResult;

/// Code generation target
#[derive(Debug, Clone, Copy)]
pub enum Target {
    JavaScript,
    Llvm,
    Beam,
}

/// Generated code output
pub struct CodeOutput {
    pub target: Target,
    pub code: String,
    pub source_map: Option<String>,
}

/// Generate code for an expression
pub fn codegen(expr: &Expr, target: Target) -> CompileResult<CodeOutput> {
    match target {
        Target::JavaScript => codegen_js(expr),
        Target::Llvm => codegen_llvm(expr),
        Target::Beam => codegen_beam(expr),
    }
}

fn codegen_js(expr: &Expr) -> CompileResult<CodeOutput> {
    let mut output = String::new();
    output.push_str("// Generated by betlang\n");
    output.push_str("'use strict';\n\n");

    emit_js_expr(&mut output, expr);

    Ok(CodeOutput {
        target: Target::JavaScript,
        code: output,
        source_map: None,
    })
}

fn emit_js_expr(out: &mut String, expr: &Expr) {
    match expr {
        Expr::Literal(lit) => emit_js_literal(out, lit),
        Expr::Var(name) => out.push_str(name),
        Expr::Bet(bet) => {
            out.push_str("(function() { ");
            out.push_str("const __alts = [");
            for (i, alt) in bet.alternatives.iter().enumerate() {
                if i > 0 {
                    out.push_str(", ");
                }
                emit_js_expr(out, &alt.value);
            }
            out.push_str("]; ");
            out.push_str("return __alts[Math.floor(Math.random() * 3)]; ");
            out.push_str("})()");
        }
        _ => out.push_str("undefined"), // Placeholder
    }
}

fn emit_js_literal(out: &mut String, lit: &Literal) {
    match lit {
        Literal::Unit => out.push_str("null"),
        Literal::Bool(b) => out.push_str(if *b { "true" } else { "false" }),
        Literal::Ternary(t) => match t {
            TernaryValue::True => out.push_str("1"),
            TernaryValue::False => out.push_str("-1"),
            TernaryValue::Unknown => out.push_str("0"),
        },
        Literal::Int(i) => out.push_str(&i.to_string()),
        Literal::Float(f) => out.push_str(&f.to_string()),
        Literal::String(s) => {
            out.push('"');
            out.push_str(&s.replace('\\', "\\\\").replace('"', "\\\""));
            out.push('"');
        }
    }
}

fn codegen_llvm(_expr: &Expr) -> CompileResult<CodeOutput> {
    // TODO: Implement LLVM codegen
    Ok(CodeOutput {
        target: Target::Llvm,
        code: "; LLVM IR placeholder\n".to_string(),
        source_map: None,
    })
}

fn codegen_beam(_expr: &Expr) -> CompileResult<CodeOutput> {
    // TODO: Implement BEAM codegen
    Ok(CodeOutput {
        target: Target::Beam,
        code: "%% BEAM bytecode placeholder\n".to_string(),
        source_map: None,
    })
}
